
module = {import} {global} {file} {func_decl} ;

import = "import" string ["as" [name]] ;
global = "global" variable "=" expression ;
file = "file" name "=" string ;

func_decl = "func" func_name "(" [parameter]  {","  parameter} ")" "\n"
            {statement}
            "return" [variable] "\n" ;

statement = [let_stmt | unlet_stmt | if_stmt | loop_stmt | for_stmt |
             push_stmt | pop_stmt | swap_stmt | do_stmt | mod_stmt |
	     try_stmt | catch_stmt | call_stmt | print_stmt] "\n" ;

let_stmt = "let" variable "=" (expression | array_generator | func_call) ;

unlet_stmt = "unlet" variable "=" (expression | array_generator | func_call) ;

push_stmt = "push" (variable "=>" variable) |
	    	   (variable "<=" variable) ;

pop_stmt = "pop" (variable "<=" variable) |
    	   (variable "=>" variable) ;

swap_stmt = "swap" variable "<=>" variable ;

if_stmt = "if" "(" expression ")" "\n"
          {statement}
	  ["else" "\n" {statement}]
	  "fi" ["(" expression ")"] ;

loop_stmt = "loop" "(" expression ")" "\n"
            {statement}
	    "while" "(" expression ")" ;

for_stmt = "for" "(" var_name "=" expression ")" "\n"
            {statement}
	    "rof" "(" var_name "=" expression ")" ;

do_stmt = "do" "\n"
          {statement}
	  "yield" "\n"
	  {yieldable_stmt}
	  "undo" ;

yieldable_statement = [let_stmt | unlet_stmt | print_stmt] "\n" ;

try_stmt = "try" "(" name "in" variable | array_generator ")" "\n"
           {statement}
	   "yrt" ;

catch_stmt = "catch" "(" expression ")" ;

mod_stmt = variable "+=" expression
         | variable "-=" expression
         | variable "*=" expression
         | variable "/=" expression ;

print_stmt = "print" "(" variable {"," variable} ")" ;

array_generator = "[" expression "for" name "in" array_generator "]"
                  | "[" expression "to" expression [ "by" expression ] "]" ;

func_call = func_name ["{" expression "}"] "(" [parameter] {',' parameter} ")" ;

parameter = ["@"] var_name ;

variable = var_name {"[" expression "]"} ;

expression = number
           | ['#'] variable
	   | unary_op expression
	   | expression binary_op expression
	   | '(' expression ')' ;

binary_op = "+" | "-" | "*" | "/" | "//" | "**" | "%" |
            "^" | "|" | "&" | "<=" | ">=" | "!=" | "=" |
	    "<" | ">" ;
	    
unary_op = "!" | "-" ;

func_name = ['~'] name ;

var_name = ['.'] name ;

name = "[a-zA-Z_][a-zA-Z0-9_.]*" ;

string = "\"[^\"]*\"" ;

number = "\d+(\/\d+)?" ;