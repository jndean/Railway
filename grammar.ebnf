
module = {import} {global} {file} {func_decl} ;

import = "import" string ["as" [name]] ;
global = "global" lookup "=" expression ;
file = "file" name "=" string ;

func_decl = "func" func_name "(" [parameter]  {","  parameter} ")" "\n"
            {statement}
            "return" [lookup] "\n" ;

statement = [let_stmt | unlet_stmt | if_stmt | loop_stmt | for_stmt |
             push_stmt | pop_stmt | swap_stmt | do_stmt | mod_stmt |
	     try_stmt | catch_stmt | call_stmt | print_stmt] "\n" ;

let_stmt = "let" lookup "=" (expression | array_generator | func_call) ;

unlet_stmt = "unlet" lookup "=" (expression | array_generator | func_call) ;

push_stmt = "push" (lookup "=>" lookup) |
	    	   (lookup "<=" lookup) ;

pop_stmt = "pop" (lookup "<=" lookup) |
    	   (lookup "=>" lookup) ;

swap_stmt = "swap" lookup "<=>" lookup ;

if_stmt = "if" "(" expression ")" "\n"
          {statement}
	  ["else" "\n" {statement}]
	  "fi" ["(" expression ")"] ;

loop_stmt = "loop" "(" expression ")" "\n"
            {statement}
	    "while" "(" expression ")" ;

for_stmt = "for" "(" var_name "=" expression ")" "\n"
            {statement}
	    "rof" "(" var_name "=" expression ")" ;

do_stmt = "do" "\n"
          {statement}
	  "yield" "\n"
	  {yieldable_stmt}
	  "undo" ;

yieldable_statement = [let_stmt | unlet_stmt | print_stmt] "\n" ;

try_stmt = "try" "(" name "in" lookup | array_generator ")" "\n"
           {statement}
	   "yrt" ;

catch_stmt = "catch" "(" expression ")" ;

mod_stmt = lookup "+=" expression
         | lookup "-=" expression
         | lookup "*=" expression
         | lookup "/=" expression ;

print_stmt = "print" "(" lookup {"," lookup} ")" ;

array_generator = "[" expression "for" name "in" array_generator "]"
                  | "[" expression "to" expression [ "by" expression ] "]" ;

func_call = func_name ["{" expression "}"] "(" [parameter] {',' parameter} ")" ;

parameter = ["@"] var_name ;

lookup = var_name {"[" expression "]"} ;

expression = number
           | ['#'] lookup
	   | unary_op expression
	   | expression binary_op expression
	   | '(' expression ')' ;

binary_op = "+" | "-" | "*" | "/" | "//" | "**" | "%" |
            "^" | "|" | "&" | "<=" | ">=" | "!=" | "=" |
	    "<" | ">" ;
	    
unary_op = "!" | "-" ;

func_name = ['~'] name ;

var_name = ['.'] name ;

name = "[a-zA-Z_][a-zA-Z0-9_.]*" ;

string = "\"[^\"]*\"" ;

number = "\d+(\/\d+)?" ;