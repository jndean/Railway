
func matmul_threaded(L, R)
  let .out[0] = 0
  for (outidx = 0)
    let .sum = 0
    for (i = 0)
      .sum += L[THREAD_ID][i] * R[i][outidx]
    rof (i = #R)
    push .sum => .out
  rof (outidx = #R[0])
return .out


func ~argmax(X)
  let range = [i for i in [#X]]
  try (best in range)
    for (i = 0)
      catch (X[i] > X[best])
    rof (i = #X)
  yrt
  unlet range = [i for i in [#X]]
return best


	
func argmax_alt(X)
  let .best = 0
  for (i = 0)
    if (X[i] > X[.best])
      .best = i
    fi
  rof (#X)
return .best

	
func main(argv)
  do
    let M[5][5] = 5/6
    let V[5][2] = 1
    call{5} X = matmul_threaded(M, V)
  yield
    print(X)
  undo
return


func altmain(argv)
  let M[5][5] = 5/6
  let V[5][2] = 1
  call{5} X = matmul_threaded(M, V)
  print (X)
  uncall{5} X = matmul_threaded(M, V)
  unlet V[5][2] = 1
  unlet M[5][5] = 5/6
return
